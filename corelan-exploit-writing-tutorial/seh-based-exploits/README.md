* An __exception handler__ is a piece of code that is written inside an application, with the purpose of dealing with the fact that the application throws an execption. A typical exception handler looks like this :
```
try {
	//run stuff.  If an exception occurs, go to  code
}
catch{
	// run stuff when exception occurs
}
```
* A quick look on the stack on how the try & catch blocks are related to each other and placed on the stack <p align="center"><img src="https://i.imgur.com/1uqS5Nv.png"  width="400px" height="auto"></p>
* Windows has a default __SEH (Structured Exception Handler)__ which will catch exceptions. If Windows catches an exception, you’ll see a “xxx has encountered a problem and needs to close” popup. This is often the result of the __default__ handler kicking in (UnhandledExceptionFilter)
* Check is an exception handler is registered:  ```s 00400000 l 0040c000 64 A1```. __64 A1__ is the opcode for fs[0]
* This is proof that an exception handler is registered. Dump the TEB -> ```d fs:[0]``` should be != 0xffffffff.

### Changes in Windows XP SP1 with regards to SEH, and the impact of GS/DEP/SafeSEH and other protection mechanisms on exploit writing:
* XOR: In order to be able to build an exploit based on SEH overwrite, we will need to make a distinction between __Windows XP pre-SP1__ and __SP and up__. Since Windows XP SP1, before the exception handler is called, all registers are __XORed__ with each other, making them all contain 0x00000000, which means you won’t be able to find a reference to your payload in one of the registers. 
* SafeSEH: Some additional protection was added to compilers, helping to stop the abuse of SEH overwrites. This protection mechanism is active for all modules that are compiled with __/safeSEH__.

### How to exploit:
* The theory behind this technique is: If we can overwrite the pointer to the SE handler that will be used to deal with a given exception, and we can cause the application to throw another exception (a forced exception), we should be able to get control by forcing the application to jump to your shellcode (instead of to the real exception handler function).

* A typical payload will look like this: [Junk][nSEH][SEH][Nop-Shellcode]
	* Where nSEH = the jump to the shellcode, and SEH is a reference to a pop pop ret
* Further down the stack, we see FFFFFFFF, which looks likeindicates the end of the SEH chain.
* In a typical RET overflow, you overwrite EIP and make it jump to your shellcode.
	- it may also suffer from buffer size problems, limiting the amount of space available to host your shellcode.
* When an exception occurs, the exception dispatcher creates its own stack frame. It will push elements from the EH Handler on to the newly created stack (as part of a function prologue).� One of the fields in the EH Structure is the EstablisherFrame.� This field points to the address of the exception registration record (the next SEH) that was pushed onto the program stack. This same address is also located at ESP+8 when the handler is called.