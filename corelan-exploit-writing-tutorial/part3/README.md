- This is proof that an exception handler is registered. Dump the TEB -> d fs:[0] != 0xffffffff.
- Since Windows XP SP1, before the exception handler is called, all registers are XORed with each other, making them all contain 0x00000000,
- On top of that, Stack Cookies (via C++ compiler options) and DEP (Data Execution Prevention) were introduced (Windows XP SP2 and Windows 2003). 
- A typical payload will look like this: [Junk][nSEH][SEH][Nop-Shellcode]
	* Where nSEH = the jump to the shellcode, and SEH is a reference to a pop pop ret
- Further down the stack, we see FFFFFFFF, which looks likeindicates the end of the SEH chain.
- In a typical RET overflow, you overwrite EIP and make it jump to your shellcode.
	- it may also suffer from buffer size problems, limiting the amount of space available to host your shellcode.
- When an exception occurs, the exception dispatcher creates its own stack frame. It will push elements from the EH Handler on to the newly created stack (as part of a function prologue).� One of the fields in the EH Structure is the EstablisherFrame.� This field points to the address of the exception registration record (the next SEH) that was pushed onto the program stack. This same address is also located at ESP+8 when the handler is called.